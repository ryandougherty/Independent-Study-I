\section{Counting Complexity}

We have defined the $\P$ class as the set of languages that are solvable on a deterministic TM in polynomial time. However, we did not actually describe the solution(s) - for example, we only described whether a given 3SAT formula is satisfiable, and not how many satisfying solutions it has. Note that describing solutions is not a decision problem. However, we will make the necessary modifications:

\newcommand{\SharpP}{\lang{\#P}}
\begin{definition}
A function $f \in \SharpP$ if there is a polynomial $p$ and a poly-time TM $M$ such that for all $x$, $f(x) = |\left \{y \in \{0, 1\}^{p(|x|)} \colon M(x, y) = 1\right \}|$.
\end{definition}

We can see that instead of determining membership, $f$ counts the number of solutions such that the TM accepts. Clearly, the problems in $\SharpP$ are ``harder" than those in $\P$. But what if we want to have a decision version on $\SharpP$? We can do so with $\PP$:

\begin{definition}
We have $L \in \PP$ if there is a poly-time TM $M$ and a polynomial $p$ such that for all $x$, $x \in L$ if and only if $|\left\{u \in \{0, 1\}^{p(|x|)} \colon M(x, u) = 1\right\} | \ge 2^{p(|x|)-1}$.
\end{definition}
We can see that $\PP$ is basically a ``majority selector," in that $x \in L$ if more than half of all certificates have the TM accept. For the next theorem, we define $\FP$ as the set of functions computable by a deterministic poly-time TM.

\begin{theorem}
$\PP = \P$ if and only if $\SharpP = \FP$. 
\end{theorem}

\begin{proof}
It is easy to see that $\SharpP = \FP$ implies $\PP = \P$. 
\end{proof}
\Comment{Complete this proof}

\subsection{$\SharpP$-completeness}
\begin{definition}
Define $\FP^{f}$ for a function $f$ to be the set of functions computable by poly-time TMs with oracle access to $f$ (same notation as for problems). We have $f$ to be $\SharpP$-complete if:
\begin{itemize}
\item $f \in \SharpP$
\item For all $g \in \SharpP$, $g \in \FP^{f}$.
\end{itemize}
\end{definition}

\newcommand{\SharpSAT}{\lang{\#\SAT}}
\begin{theorem}
$\SharpSAT$ is $\SharpP$-complete.
\end{theorem}

\begin{proof}
The reasoning is that the reduction for $\SAT$ is \emph{parsimonious} (i.e., is bijective and preserves counts). 
\end{proof}

\subsection{Toda's Theorem}
How powerful is $\SharpP$? It has been hard to determine until 1989, with one amazing result by Toda:
\begin{theorem}
$\PH \subseteq \P^{\#\SAT}$. 
\end{theorem}
This means that with any $\SharpP$-complete problem, we can solve any problem in $\PH$ (i.e., a subexponential algorithm). We build the necessary ingredients for the proof:

\newcommand{\Parity}{\oplus}
\newcommand{\ParityP}{\lang{\Parity\P}}
\begin{definition}
We have $\L \in \ParityP$ (``parity-$\P$") if there is a poly-time \emph{nondeterministic} TM $M$ such that $x \in L$ if and only if there are an odd number of accepting paths of $M$ on $x$. 
\end{definition}
\newcommand{\ParitySAT}{\Parity\SAT}
Also, we need to know about the $\Parity$ quantifier as well as $\ParitySAT$:
\begin{definition}
For a boolean formula $\phi$, define $\Parity\phi(x)$ to be true if the number of $x$'s that make $\phi$ true is odd. Define $\ParitySAT$ to be the language of $\Parity\phi(x)$ where $\phi$ is an unquantified boolean formula in any form.
\end{definition}
We can reason that $\ParityP$ corresponds to the least significant bit of problems in $\SharpP$, so it doesn't seem very powerful. However, in the first part of the proof, Toda shows a randomized reduction from $\PH$ to $\ParitySAT$. 
\Comment{Add other parts of proof}
