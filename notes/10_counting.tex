\section{Counting Complexity}

We have defined the $\P$ class as the set of languages that are solvable on a deterministic TM in polynomial time. However, we did not actually describe the solution(s) - for example, we only described whether a given 3SAT formula is satisfiable, and not how many satisfying solutions it has. Note that describing solutions is not a decision problem. However, we will make the necessary modifications:

\newcommand{\SharpP}{\lang{\#P}}
\begin{definition}
A function $f \in \SharpP$ if there is a polynomial $p$ and a poly-time TM $M$ such that for all $x$, $f(x) = |\left \{y \in \{0, 1\}^{p(|x|)} \colon M(x, y) = 1\right \}|$.
\end{definition}

We can see that instead of determining membership, $f$ counts the number of solutions such that the TM accepts. Clearly, the problems in $\SharpP$ are ``harder" than those in $\P$. But what if we want to have a decision version on $\SharpP$? We can do so with $\PP$:

\begin{definition}
We have $L \in \PP$ if there is a poly-time TM $M$ and a polynomial $p$ such that for all $x$, $x \in L$ if and only if $|\left\{u \in \{0, 1\}^{p(|x|)} \colon M(x, u) = 1\right\} | \ge 2^{p(|x|)-1}$.
\end{definition}
We can see that $\PP$ is basically a ``majority selector," in that $x \in L$ if more than half of all certificates have the TM accept. For the next theorem, we define $\FP$ as the set of functions computable by a deterministic poly-time TM.

\begin{theorem}
$\PP = \P$ if and only if $\SharpP = \FP$. 
\end{theorem}

\begin{proof}
It is easy to see that $\SharpP = \FP$ implies $\PP = \P$. 
\end{proof}
\Comment{Complete this proof}

\subsection{$\SharpP$-completeness}
\begin{definition}
Define $\FP^{f}$ for a function $f$ to be the set of functions computable by poly-time TMs with oracle access to $f$ (same notation as for problems). We have $f$ to be $\SharpP$-complete if:
\begin{itemize}
\item $f \in \SharpP$
\item For all $g \in \SharpP$, $g \in \FP^{f}$.
\end{itemize}
\end{definition}

\newcommand{\SharpSAT}{\lang{\#\SAT}}
\begin{theorem}
$\SharpSAT$ is $\SharpP$-complete.
\end{theorem}

\begin{proof}
The reasoning is that the reduction for $\SAT$ is \emph{parsimonious} (i.e., is bijective and preserves counts). 
\end{proof}

\newcommand{\SharpPSPACE}{\lang{\#\PSPACE}}
\subsection{$\SharpPSPACE$}
We have talked about $\SharpP$ - what about $\SharpPSPACE$? We define it below:
\begin{definition}
A function $f \in \SharpPSPACE$ if there is a poly-time TM $M$ such that $f(x)$ outputs the number of possible $x_1, \cdots, x_k$ such that $Q_1x_1 \cdots Q_kx_k [M(x_1, \cdots, x_k) = 1]$. 
\end{definition}
\newcommand{\SharpQBF}{\lang{\#QBF}}
We also define $\SharpPSPACE$-completeness the same way we have $\SharpP$-completeness. We can easily see that $\SharpQBF \in \SharpPSPACE$, where $\SharpQBF$ is the same as the $\lang{QBF}$ problem but we count the number of solutions. We will show that $\SharpQBF = \SharpSAT$, thereby giving the result that:
\begin{theorem}
$\SharpP = \SharpPSPACE$.
\end{theorem}

\begin{proof}
We introduce the ``circuit value problem" (CVP), which is: given a boolean formula $\phi$ and an assignment $x$ to its variables, is $\phi$ true with this assignment? It is much easier than solving $\SAT$, and is in $\P$. 

\par We show that $\SharpQBF \in \SharpPSPACE$: let $M$ be a TM that decides CVP, and $Q_1x_1 \cdots Q_kx_k [\phi]$ be an arbitrary QBF. Therefore, the number of settings to the $x_i$ such that $M(\phi, x)$ accepts is precisely the number of $x_i$ settings that make $\phi$ true. Therefore, $\SharpQBF \in \SharpPSPACE$.

\par Let $f \in \SharpPSPACE$. Therefore, there is a poly-time TM $M$ such that $f(x)$ is the number of $Q_ix_i$ settings that $M(x) = 1$. Let $L$ be the set of $x$ such that $M(x) = 1$. We can see that $L \in \P$ (just run $M$ on the input). Let $g$ be the poly-time reduction from $L$ to CVP (i.e., $M(x) = 1$ if and only if $g(x)$ is a formula with a satisfying truth assignment). 

\par Therefore, $f(x)$ is the number of $Q_ig(x_i)$ settings that has the 
\end{proof}

\subsection{Toda's Theorem}
How powerful is $\SharpP$? It has been hard to determine until 1989, with one amazing result by Toda:
\begin{theorem}
$\PH \subseteq \P^{\#\SAT}$. 
\end{theorem}
This means that with any $\SharpP$-complete problem, we can solve any problem in $\PH$ (i.e., a subexponential algorithm). We build the necessary ingredients for the proof:

\newcommand{\Parity}{\oplus}
\newcommand{\ParityP}{\lang{\Parity\P}}
\begin{definition}
We have $\L \in \ParityP$ (``parity-$\P$") if there is a poly-time \emph{nondeterministic} TM $M$ such that $x \in L$ if and only if there are an odd number of accepting paths of $M$ on $x$. 
\end{definition}
\newcommand{\ParitySAT}{\Parity\SAT}
Also, we need to know about the $\Parity$ quantifier as well as $\ParitySAT$:
\begin{definition}
For a boolean formula $\phi$, define $\Parity\phi(x)$ to be true if the number of $x$'s that make $\phi$ true is odd. Define $\ParitySAT$ to be the language of $\Parity\phi(x)$ where $\phi$ is an unquantified boolean formula in any form.
\end{definition}
We can reason that $\ParityP$ corresponds to the least significant bit of problems in $\SharpP$, so it doesn't seem very powerful. However, in the first part of the proof, Toda shows a randomized reduction from $\PH$ to $\ParitySAT$. 
\Comment{Add other parts of proof}
