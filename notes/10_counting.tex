\section{Counting Complexity}

We have defined the $\P$ class as the set of languages that are solvable on a deterministic TM in polynomial time. However, we did not actually describe the solution(s) - for example, we only described whether a given 3SAT formula is satisfiable, and not how many satisfying solutions it has. Note that describing solutions is not a decision problem. However, we will make the necessary modifications:

\newcommand{\SharpP}{\lang{\#P}}
\begin{definition}
A function $f \in \SharpP$ if there is a polynomial $p$ and a poly-time TM $M$ such that for all $x$, $f(x) = |\left \{y \in \{0, 1\}^{p(|x|)} \colon M(x, y) = 1\right \}|$.
\end{definition}

We can see that instead of determining membership, $f$ counts the number of solutions such that the TM accepts. Clearly, the problems in $\SharpP$ are ``harder" than those in $\P$. But what if we want to have a decision version on $\SharpP$? We can do so with $\PP$:

\begin{definition}
We have $L \in \PP$ if there is a poly-time TM $M$ and a polynomial $p$ such that for all $x$, $x \in L$ if and only if $|\left\{u \in \{0, 1\}^{p(|x|)} \colon M(x, u) = 1\right\} | \ge 2^{p(|x|)-1}$.
\end{definition}
We can see that $\PP$ is basically a ``majority selector," in that $x \in L$ if more than half of all certificates have the TM accept. For the next theorem, we define $\FP$ as the set of functions computable by a deterministic poly-time TM.

\begin{theorem}
$\PP = \P$ if and only if $\SharpP = \FP$. 
\end{theorem}

\begin{proof}
It is easy to see that $\SharpP = \FP$ implies $\PP = \P$: given input $x$, just count the number of $u$ such that $M(x, u) = 1$, and compare. For the other direction
\end{proof}
\Comment{Complete this proof}

\subsection{$\SharpP$-completeness}
\begin{definition}
Define $\FP^{f}$ for a function $f$ to be the set of functions computable by poly-time TMs with oracle access to $f$ (same notation as for problems). We have $f$ to be $\SharpP$-complete if:
\begin{itemize}
\item $f \in \SharpP$
\item For all $g \in \SharpP$, $g \in \FP^{f}$.
\end{itemize}
\end{definition}

\newcommand{\SharpSAT}{\lang{\#\SAT}}
\begin{theorem}
$\SharpSAT$ is $\SharpP$-complete.
\end{theorem}

\begin{proof}
The reasoning is that the reduction for $\SAT$ is \emph{parsimonious} (i.e., is bijective and preserves counts). 
\end{proof}

\newcommand{\SharpPSPACE}{\lang{\#\PSPACE}}
\subsection{$\SharpPSPACE$}
We have talked about $\SharpP$ - what about $\SharpPSPACE$? We define it below:
\begin{definition}
A function $f \in \SharpPSPACE$ if there is a poly-time TM $M$ such that $f(x)$ outputs the number of possible $x_1, \cdots, x_k$ such that $Q_1x_1 \cdots Q_kx_k [M(x_1, \cdots, x_k) = 1]$. 
\end{definition}
\newcommand{\SharpQBF}{\lang{\#QBF}}
We also define $\SharpPSPACE$-completeness the same way we have $\SharpP$-completeness. We can easily see that $\SharpQBF \in \SharpPSPACE$, where $\SharpQBF$ is the same as the $\lang{QBF}$ problem but we count the number of solutions. We will show that $\SharpQBF = \SharpSAT$, thereby giving the result that:
\begin{theorem}
$\SharpP = \SharpPSPACE$.
\end{theorem}

\begin{proof}
The way we will prove this is showing $\SharpQBF$ is $\SharpPSPACE$-complete, and $\SharpQBF = \SharpSAT$.

We clearly have $\SharpQBF \in \SharpPSPACE$ (there is a poly-space TM $M$ that for any boolean formula $F$, and quantification of variables, $M$ accepts on the quantification if and only if the quantification for the formula is true).

\par Let $f \in \SharpPSPACE$. There is a poly-space TM $M$ and polynomial $p$ such that $f(x)$ is the number of $x_1, \cdots x_k$ has $Q_1x_1\cdots Q_{p(|x|)}x_{p(|x|)} M(x, x_1, \cdots, x_{p(|x|)})$ accepts.

\par Let $F_x(x_1, \cdots x_{p(|x|)})$ be the equivalent formula of $M$ (this is of poly-size). Therefore, $f(x)$ is the number of quantifications such that $F_x$ is true, which is equal to counting the solutions of the formula (i.e., $\SharpQBF(F_x)$). Therefore, $f \le_{\SharpP} \SharpQBF$. 

\par Now we show $\SharpQBF = \SharpSAT$. Let $F$ be a boolean formula on $n$ variables. We prove by induction on $n$. For $n=0$, the two formulas with no variables are the true formula $t$ and the false one $f$. $\SharpSAT(t) = \SharpQBF(t) = 1$ (there are no quantifications), and $\SharpSAT(f) = \SharpQBF(f) = 0$. 

\par We assume that $\SharpSAT(m) = \SharpQBF(m)$ for all formulas $m$ with $n-1$ variables. Let $F'$ be a formula on $n$ variables, and let $F'_t, F'_f$ be the same formula but with the last variable made true and false, respectively. We note the following:
\begin{itemize}
\item $\SharpSAT(F'_t \vee F'_f) = \SharpSAT(F'_t) + \SharpSAT(F'_f) - \SharpSAT(F'_t \wedge F'_f)$.
\item Let $Q^kx = Q_1x_1 \cdots Q_kx_k$ be the first $k$ quantified variables of $F'$. Then $Q^{n-1}x\forall x_n F'$ is true if and only if $Q^{n-1}x(F'_t \wedge F'_f)$ is true, and $Q^{n-1}x\exists x_n F'$ is true if and only if $Q^{n-1}x(F'_t \vee F'_f)$ is true. 
\end{itemize}
We also see that $\SharpQBF(F')$ is the number of quantifications of $F'$ that make it true with the $n$th variable as $\exists$ + the same but the $n$th variable is $\forall$. Therefore, $\SharpQBF(F') = \SharpQBF(F'_t \wedge F'_f) + \SharpQBF(F'_t \vee F'_f)$.

\par We assume by the induction hypothesis that this is equivalent to $\SharpSAT(F'_t \wedge F'_f) + \SharpSAT(F'_t \vee F'_f)$. Also, by the first observation, this is equivalent to $\SharpSAT(F'_t) + \SharpSAT(F'_f)$, which is equal to $\SharpSAT(F')$. 

\par We have $\SharpP = \SharpPSPACE$ because of our definition of $\SharpP$-completeness. 

%We introduce the ``circuit value problem" (CVP), which is: given a boolean formula $\phi$ and an assignment $x$ to its variables, is $\phi$ true with this assignment? It is much easier than solving $\SAT$, and is in $\P$. 
%
%\par We show that $\SharpQBF \in \SharpPSPACE$: let $M$ be a TM that decides CVP, and $Q_1x_1 \cdots Q_kx_k [\phi]$ be an arbitrary QBF. Therefore, the number of settings to the $x_i$ such that $M(\phi, x)$ accepts is precisely the number of $x_i$ settings that make $\phi$ true. Therefore, $\SharpQBF \in \SharpPSPACE$.
%
%\par Let $f \in \SharpPSPACE$. Therefore, there is a poly-time TM $M$ such that $f(x)$ is the number of $Q_ix_i$ settings that $M(x) = 1$. Let $L$ be the set of $x$ such that $M(x) = 1$. We can see that $L \in \P$ (just run $M$ on the input). Let $g$ be the poly-time reduction from $L$ to CVP (i.e., $M(x) = 1$ if and only if $g(x)$ is a formula with a satisfying truth assignment). 
%
%\par Therefore, $f(x)$ is the number of $Q_ig(x_i)$ settings that has the 
\end{proof}

\subsection{Toda's Theorem}
How powerful is $\SharpP$? It has been hard to determine until 1989, with one amazing result by Toda:
\begin{theorem}
$\PH \subseteq \P^{\#\SAT}$. 
\end{theorem}
This means that with any $\SharpP$-complete problem, we can solve any problem in $\PH$ (i.e., a subexponential algorithm). We build the necessary ingredients for the proof:

\newcommand{\Parity}{\oplus}
\newcommand{\ParityP}{\lang{\Parity\P}}
\begin{definition}
We have $\L \in \ParityP$ (``parity-$\P$") if there is a poly-time \emph{nondeterministic} TM $M$ such that $x \in L$ if and only if there are an odd number of accepting paths of $M$ on $x$. 
\end{definition}
\newcommand{\ParitySAT}{\Parity\SAT}
Also, we need to know about the $\Parity$ quantifier as well as $\ParitySAT$:
\begin{definition}
For a boolean formula $\phi$, define $\Parity\phi(x)$ to be true if the number of $x$'s that make $\phi$ true is odd. Define $\ParitySAT$ to be the language of $\Parity\phi(x)$ where $\phi$ is an unquantified boolean formula in any form.
\end{definition}
We can reason that $\ParityP$ corresponds to the least significant bit of problems in $\SharpP$, so it doesn't seem very powerful. However, in the first part of the proof, Toda shows a randomized reduction from $\PH$ to $\ParitySAT$. 
\Comment{Add other parts of proof}
