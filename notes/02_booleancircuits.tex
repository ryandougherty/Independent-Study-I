\section{Boolean Circuits}

We have looked a little at boolean formulas, which take input variables that have values ``true" or ``false" and, through some operations, give a result of either ``true" or ``false" as ``output." Here, we look at circuits, which are a generalization of formulas.

\begin{definition}
A \emph{boolean circuit} is a DAG (directed acyclic graph) with a number of ``source" vertices (those with no incoming edges), also called ``gates," and a ``sink" vertex (with no outgoing edges), also called the ``output." Vertices are labelled with $\wedge, \vee, \neg$ - those with $\wedge, \vee$ have fan-in 2 and fan-out 1, and those with $\neg$ have fan-in and fan-out 1. The \emph{size} of a circuit is the number of vertices it has. The output of a particular input $x \in \{0, 1\}^n$ is applying each of the vertex ``rules" recursively until the output is reached. 
\end{definition}

\begin{theorem}
Any circuit with its $\wedge, \vee$ vertices having bounded fan-in (i.e., $\ge 3$) can be converted to an equivalent circuit with these vertices having only fan-in 2. 
\end{theorem}

\begin{definition}
A \emph{$T(n)$-size circuit family} is a sequence of circuits (i.e., $\{C_n\}_{n \in \mathbb{N}}$), where, for a given function $T \colon \mathbb{N} \rightarrow \mathbb{N}$, has that all of the circuits have size $\le T(n)$ for all $n$. We say that $L \in \SIZE(T(n))$ if there exists a $T(n)$-size circuit family such that for all $x \in \{0, 1\}^n$, $x \in L$ if and only if $C_n(x) = 1$ (i.e., ``accepts" $x$). 
\end{definition}

We start with an example: $L_1 = \{1^n \colon n \in \mathbb{Z}\}$.
\begin{theorem}
\label{thm:unary_linear_circuit_family}
$L_1$ can be decided by a linear-sized circuit family. 
\end{theorem}

\begin{proof}
The circuit is simply a tree of $\wedge$ gates that computes that of all inputs. 
\end{proof}

\begin{definition}
We define $\Ppoly$ to be $\bigcup_{c} \SIZE(n^c)$; in other words, $\Ppoly$ is the set of languages with poly-size circuit families.
\end{definition}

\begin{theorem}
\label{thm:all_unary_ppoly}
All unary languages are in $\Ppoly$.
\end{theorem}

\begin{proof}
Implied by \Cref{thm:unary_linear_circuit_family}.
\end{proof}

\begin{theorem}
\label{thm:p_subset_ppoly}
$\P \subseteq \Ppoly$, and the inclusion is strict.
\end{theorem}

\begin{proof}
Let $M$ be an ``oblivious" TM, which is one that has its head movement independent of the input. We need to show that for any $T(n)$-time oblivious TM, we can construct an equivalent $O(T(n))$-size circuit family. 

\par Let $x$ be an input for $M$, and look at the set of $M$'s configurations: $C_1, \cdots, C_{T(n)}$. Encode each configuration by a constant-size binary string. We can compute $C_i$ based on the following:
\begin{itemize}
\item $x$ itself,
\item $C_{i-1}$,
\item $C_{i_1}, \cdots, C_{i_k}$, where $C_{i_j}$ is the last step that $M$'s $j$th head was in the same position as it is in the $i$th step.
\end{itemize}
Because we assumed $M$ is oblivious, then $i_1, \cdots, i_k$ does not depend on $x$ - they only depend on $i$. Therefore, since we only have a constant number of strings of constant size, we can compute $C_i$ with a constant-size circuit.

\par We compose these circuits together so that, on input $x$, we compute $C_{T(n)}$ on $M$'s last step in its execution on $x$. We also have a constant size circuit that outputs 1 if and only if $C_{T(n)}$ is an accepting configuration. Since we have $O(T(n))$ circuits of constant size, we have constructed an equivalent $O(T(n))$-size circuit to $M$.

\par For showing strict containment, by \Cref{thm:all_unary_ppoly}, all undecidable unary languages are in $\Ppoly$, which are by definition not in $\P$.
\end{proof}



\newcommand{\CKTSAT}{\lang{CKT-SAT}}
\subsection{\CKTSAT}
As we proved the Cook-Levin Theorem from before, now we prove the circuit analog of $\SAT$. $\CKTSAT$ is the set of all circuits that have a ``satisfying assignment" to the $n$ input variables. In other words, there exists a $w \in \{0, 1\}^n$ if and only if $C(w)=1$ if $C \in \CKTSAT$.

\begin{theorem}
$\CKTSAT$ is $\NP$-complete.
\end{theorem}

\begin{proof}
$\CKTSAT$ is clearly in $\NP$. For hardness, if $L \in \NP$, then there is a verifier $V$ such that, on input $x$, verifies if $x \in L$ in polynomial time. By \Cref{thm:p_subset_ppoly}, we can convert $V$ into an equivalent circuit $C$ in polynomial time. Therefore, $x \in L$ if and only if $C \in \CKTSAT$.
\end{proof}

\subsection{Advice!}
We defined $\Ppoly$ in one way - now we will see another. This will make the fact that all undecidable unary languages are in $\Ppoly$ to be more clear. 

\begin{definition}
The set of languages \emph{decidable by $T(n)$-time TMs with $A(n)$ bits of advice} is called $\DTIME(T(n))/A(n)$. By this, we mean that for every $L \in \DTIME(T(n))/A(n)$, there is a sequence of strings, $\{a_n\}$, each of length $A(n)$, and a $T(n)$-time verifier $M$, such that it accepts $\langle x, a_n \rangle$ if and only if $x \in L$.
\end{definition}

In other words, we are given a sequence of strings of length $A(n)$ that are certificates, in a sense. Now we will look at the alternative definition of $\Ppoly$:
\begin{theorem}
$\Ppoly$ can be re-defined to be $\bigcup_{c, d \ge 0} \DTIME(n^c)/n^d$.
\end{theorem}

\begin{proof}
By the first definition of $\Ppoly$, if $L \in \Ppoly$, then $L$ is computable by a poly-size circuit family $\{C_n\}$. We can just use the descriptions of each of the $C_n$ as an advice string, and the TM is poly-time that, on input $\langle x, C \rangle$, where $C$ is an $n$-input circuit, outputs $C(x)$. 

\par If $L$ is decided by a poly-time TM $M$ with access to the sequence of advice strings $\{a_n\}$, each of poly-length, then we can use the construction of \Cref{thm:p_subset_ppoly} to obtain an equivalent poly-size circuit $B_n$ for all $n$ (i.e., outputs the same as $M$ does). Let $C_n$ be the same as $B_n$ but with $a_n$ hard-coded as the second input (i.e., fix the inputs). Therefore, $\{C_n\}$ is the desired circuit-family.
\end{proof}

We can actually get a ``nondeterministic" parallel to \Cref{thm:p_subset_ppoly}:

\begin{theorem}
$\NP \subseteq \bigcup_{c, d \ge 0} \NTIME(n^c)/n^d$, and the inclusion is strict (note $\NTIME$ instead of $\DTIME$).
\end{theorem}

\begin{proof}
It's easy to see inclusion: set $d = 0$, and have an $\NP$ machine accept a one-bit advice string for every $n$, and have the machine ignore the advice. 

\par For strict inclusion, we know that all unary languages are in $\DTIME(n)/1 \subseteq \NTIME(n)/1$, because we only need one bit of advice for each $n$ in advising the machine to check if $1^n$ is in the language. However, the following undecidable language is also in there, and therefore is not in $\NP$:
\begin{center}
$UHALT = \{1^n \colon n$'s binary expansion encodes $\langle M, w \rangle$ where $M$ halts on $w$\}.
\end{center}
\end{proof}

We have proved both of these, but how does $\NP$ relate to $\Ppoly$ (instead of the $\NTIME$ version)? We actually don't know for sure, as the polynomial hierarchy would collapse:

\begin{theorem}[Karp-Lipton]
If $\NP \subseteq \Ppoly$, then $\PH = \Sigma_2^\P$.
\end{theorem}

\begin{proof}
It is sufficient to show that $\NP \subseteq \Ppoly$ implies $\Sigma_3^\P \subseteq \Sigma_2^\P$. So fix a language $L \in \Sigma_3^\P$. By definition, there exists a poly-time TM $M$ and a polynomial $p$ such that if $x \in L$, then:
\begin{center}
$\exists u_1 \in \{0, 1\}^{p(|x|)} \forall u_2 \in \{0, 1\}^{p(|x|)} \exists u_3 \in \{0, 1\}^{p(|x|)} M(x, u_1, u_2, u_3)$ accepts.
\end{center}
We re-arrange this as follows with a new language $L'$: $\langle x, u_1, u_2 \rangle \in L'$ if and only if:
\begin{center}
$\exists u_3 \in \{0, 1\}^{p(|x|)} M(x, u_1, u_2, u_3)$ accepts.
\end{center}
Therefore, $L' \in \NP$ and therefore $L' \le_P \ThreeSAT$. Therefore, $\langle x, u_1, u_2 \rangle \in L'$ if and only if there exists a $\ThreeSAT$ formula $\phi$ over $x, u_1, u_2$ (reduction done in poly time). Also a NDTM $M'$ decides $L'$.

\par Now just plug in $M'$: $x \in L$ if and only if:
\begin{center}
$\exists u_1 \in \{0, 1\}^{p(|x|)} \forall u_2 \in \{0, 1\}^{p(|x|)} M'(x, u_1, u_2)$ accepts.
\end{center}
This is equivalent to:
\begin{center}
$\exists u_1 \in \{0, 1\}^{p(|x|)} \forall u_2 \in \{0, 1\}^{p(|x|)} \phi(x, u_1, u_2) \in \ThreeSAT$.
\end{center}
Now here is the central part of the proof. We assume that $\NP \subseteq \Ppoly$. Therefore, there exists a poly-size circuit $C$ for $\ThreeSAT$. We can just use $C$ to decide the expression above. So how do we find the circuit in the first place?

\par We prove the following. There exists a poly-time TM $M_C$ that, on input 3CNF formula $\phi$ with $|\phi| = n$ and a circuit $C$ with $n$ inputs such that: 
\begin{enumerate}
\item If $C$ recognizes $\ThreeSAT$ for inputs of length $n$ and $\phi \in \ThreeSAT$, then $M_C$ accepts.
\item If $\phi \notin \ThreeSAT$, then $M_C$ rejects.
\end{enumerate}
The idea is the following: repeatedly use the circuit $C$ to extract a satisfying assignment for $\phi$. Let the variables of $\phi$ be $x_1, ..., x_k$. If $C$ on input $\phi$ outputs 0, then $M_C$ rejects. Otherwise, fix $x_1$ to be false, and check if $C$ outputs 1 on the new circuit. If so, permanently fix $x_1$ to be false, and also have an array of $k$ values, and store $x_1$ to be the first element. Repeat for the other $k-1$ variables. Now we check: if $\phi$ with the assignments given have $\phi$ be true, then accept; otherwise, reject.

\par So now we go back to the original proof: we modify the statement above to be:
\begin{center}
$\exists C$ of poly-size $\exists u_1 \in \{0, 1\}^{p(|x|)} \forall u_2 \in \{0, 1\}^{p(|x|)} \M_C(C, \langle x, u_1, u_2\rangle)$ accepts.
\end{center}
Therefore, $L \in \Sigma_2^\P$.
\end{proof}

\subsection{$\AC, \NC$}
We have dealt with circuits of polynomial size, but what about the other direction? We define a similar analogue of $\L, \NL$ in space complexity but for circuits.

\begin{definition}
For $d \in \mathbb{N}$, we say $L \in \NC^d$ if L is decided by a family of poly-size, $O(\log^d n)$-depth circuits $\{C_n\}$, and $L \in \AC^d$ the same way but the gates have unbounded fan-in. We also define $\NC = \bigcup_{d \ge 0}\NC^d$ and $\AC = \bigcup_{d \ge 0}\AC^d$.
\end{definition}
So how much power does unbounded fan-in give? It only gives enough power to add a log-factor:

\begin{theorem}
$\NC^d \subseteq \AC^d \subseteq \NC^{d+1}$.
\end{theorem}
\begin{proof}
Unbounded fan-in can be simulated by a $O(\log n)$-depth tree of OR/AND gates.
\end{proof}

We also show that it is unlikely that any finite level of the $\NC^d$ hierarchy collapses (just like the $\PH$ hierarchy):
\begin{theorem}
$\NC^d = \NC^{d+1} \Rightarrow \NC = \NC^d$.
\end{theorem}

\begin{proof}
We show that $\NC^d = \NC^{d+1}$ implies $\NC^{d+1} = \NC^{d+2}$, from which the result follows. For a circuit $C$ of depth $O(\log^{d+2} n)$, partition it into $O(\log n)$ layers of size $O(\log^{d+1} n)$ each. Each partition $j$'s output is the input of $j+1$, and each contains polynomially many bits. Each bit at partition $j+1$ is computed from $j$ by a $\NC^{d+1}$ circuit. Since $\NC^d = \NC^{d+1}$, replace it by a $\NC^d$ circuit (may not be the same size, but can only be polynomially larger). This replacement has a circuit of poly-size, depth $O(\log^{d+1} n)$, and fan-in 2. Therefore, $\NC^{d+2} = \NC^{d+1} = \NC^d$. 
\end{proof}
Therefore, it is most likely that each inclusion of $\NC^d \subseteq \AC^d \subseteq \NC^{d+1}$ is strict (the only one proved, however, is $d = 0$).  So where does $\NC$ live in relation to other classes? We can show the following:
\begin{theorem}
$\NC^1 \subseteq \L$.
\end{theorem}

\begin{proof}
Given $x \in L$ with $|x| = n$, we construct the $n$th circuit of the circuit family, and then just evaluate the circuit from the output gate. Since we only need to record the path to the current gate, and any results along the path, and the fact that the circuit has log-depth, we only need log space to do this.
\end{proof}

\subsection{Parity \& Switching Lemma}
Our goal here is to separate $\AC^0$ and $\NC^1$.
\newcommand{\ParityF}{\oplus}
\begin{definition}
Let $\ParityF(x_1, \cdots, x_n)$ be the function that computes the sum of the $x_i$ $(\mod 2)$.
\end{definition}
The goal here (using the Switching Lemma) is to prove:
\begin{theorem}
\label{thm:parity_not_in_ac0}
$\ParityF \notin \AC^0$.
\end{theorem}
H$\mathring{a}$stad proved the following (called the HSL):
\begin{theorem}
Let $f$ be a $k$-DNF formula (conjunction of disjunctions where each disjunction $\le k$ variables). Let $\rho$ be a random restriction by assigning random values to $t$ randomly selected input bits. Then for all $s \ge 2$, $\Pr_{\rho}[\text{$f$ restricted to $\rho$ is not expressible in CNF}] \le (\frac{(n-t)k^{10}}{n})^{s/2}$.
\end{theorem}
\begin{lemma}
HSL implies \Cref{thm:parity_not_in_ac0}.
\end{lemma}
\begin{proof}
Let $C$ be an $\AC^0$ circuit with a simplification: every vertex has out-degree 1, all $\neg$ gates are right after the input gates, the $\wedge, \vee$ gates alternate, and the bottom level has $\wedge$ gates with in-degree also 1. It is clear that we can construct this equivalent circuit with a polynomial number of gates.

\par Let the upper bound on the number of gates be $n^c$. We restrict more variables at each step of the computation: if there are $n_i$ unrestricted variables at step $i$, then we restrict $\sqrt{n_i}$ of them for the next step. Therefore, $n_i = \sqrt[2^i]{n}$. Let $c_i = 10c \times 2^i$. With high probability, we prove that at step $i$, we have a $(d-i)$-depth circuit, with $c_i$ fan-in at the lowest level. 

\par Suppose that the last level has $\wedge$ gates and the penultimate one has $\vee$ gates; it is easy to see that each $\vee$ gate computes a $c_i$-DNF. By HSL, with probability
\[
1-\sqrt{\left(\frac{c_i^{10}}{\sqrt[2^i+1]{n}}\right)^{c_{i+1}}} \ge 1 - \frac{1}{10n^c}
\]
\end{proof}
for large-enough $n$, the function after the $(i+1)$-th iteration is expressible as a $c_{i+1}$-CNF. Since, for any CNF formula, the top gate is $\wedge$, we merge the $\wedge$ gates with the one above, which reduces the depth by 1. By the same reasoning, we can use HSL to transform the bottom-level $\vee$ gates, which has the level above it computes a $c_i$-CNF, into a $c_{i+1}$-DNF. We apply HSL at most once for each of the $n^c$ gates. Since by the union bound:
\[
\Pr[\bigcup_{i=1}^n A_i] \le \sum_{i=1}^n \Pr[A_i]
\]
we can achieve, with probability $\frac{9}{10}$, a depth-2 circuit with fan-in $c_{d-2}$ at the lowest level if we apply HSL $d-2$ times. The result is a $k$-CNF or DNF formula; we can make this constant by fixing $\le k$ variables (i.e., ensure the first clause in the DNF is true). Since $\ParityF$ is not constant under any restriction of $\le n$ variables, we have \Cref{thm:parity_not_in_ac0}.

\subsection*{Exercises}

\begin{enumerate}
\item A language $L \subseteq \{0, 1\}^*$ is sparse if there is a polynomial $p$ such that $|L \cap \{0, 1\}^n| \le p(n)$ for every $n \in \mathbb{N}$. Show that every sparse language is in $\Ppoly$.
\item Going off the previous question, show that if a sparse language is $\NP$-complete, then $\P = \NP$.
\end{enumerate}