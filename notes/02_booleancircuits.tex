\section{Boolean Circuits}

We have looked a little at boolean formulas, which take input variables that have values ``true" or ``false" and, through some operations, give a result of either ``true" or ``false" as ``output." Here, we look at circuits, which are a generalization of formulas.

\begin{definition}
A \emph{boolean circuit} is a DAG (directed acyclic graph) with a number of ``source" vertices (those with no incoming edges), also called ``gates," and a ``sink" vertex (with no outgoing edges), also called the ``output." Vertices are labelled with $\wedge, \vee, \neg$ - those with $\wedge, \vee$ have fan-in 2 and fan-out 1, and those with $\neg$ have fan-in and fan-out 1. The \emph{size} of a circuit is the number of vertices it has. The output of a particular input $x \in \{0, 1\}^n$ is applying each of the vertex ``rules" recursively until the output is reached. 
\end{definition}

\begin{theorem}
Any circuit with its $\wedge, \vee$ vertices having bounded fan-in (i.e., $\ge 3$) can be converted to an equivalent circuit with these vertices having only fan-in 2. 
\end{theorem}

\begin{definition}
A \emph{$T(n)$-size circuit family} is a sequence of circuits (i.e., $\{C_n\}_{n \in \mathbb{N}}$), where, for a given function $T \colon \mathbb{N} \rightarrow \mathbb{N}$, has that all of the circuits have size $\le T(n)$ for all $n$. We say that $L \in \SIZE(T(n))$ if there exists a $T(n)$-size circuit family such that for all $x \in \{0, 1\}^n$, $x \in L$ if and only if $C_n(x) = 1$ (i.e., ``accepts" $x$). 
\end{definition}

We start with an example: $L_1 = \{1^n \colon n \in \mathbb{Z}\}$.
\begin{theorem}
\label{thm:unary_linear_circuit_family}
$L_1$ can be decided by a linear-sized circuit family. 
\end{theorem}

\begin{proof}
The circuit is simply a tree of $\wedge$ gates that computes that of all inputs. 
\end{proof}

\begin{definition}
We define $\Ppoly$ to be $\bigcup_{c} \SIZE(n^c)$; in other words, $\Ppoly$ is the set of languages with poly-size circuit families.
\end{definition}

\begin{theorem}
\label{thm:all_unary_ppoly}
All unary languages are in $\Ppoly$.
\end{theorem}

\begin{proof}
Implied by \Cref{thm:unary_linear_circuit_family}.
\end{proof}

\begin{theorem}
\label{thm:p_subset_ppoly}
$\P \subseteq \Ppoly$, and the inclusion is strict.
\end{theorem}

\begin{proof}
Let $M$ be an ``oblivious" TM, which is one that has its head movement independent of the input. We need to show that for any $T(n)$-time oblivious TM, we can construct an equivalent $O(T(n))$-size circuit family. 

\par Let $x$ be an input for $M$, and look at the set of $M$'s configurations: $C_1, \cdots, C_{T(n)}$. Encode each configuration by a constant-size binary string. We can compute $C_i$ based on the following:
\begin{itemize}
\item $x$ itself,
\item $C_{i-1}$,
\item $C_{i_1}, \cdots, C_{i_k}$, where $C_{i_j}$ is the last step that $M$'s $j$th head was in the same position as it is in the $i$th step.
\end{itemize}
Because we assumed $M$ is oblivious, then $i_1, \cdots, i_k$ does not depend on $x$ - they only depend on $i$. Therefore, since we only have a constant number of strings of constant size, we can compute $C_i$ with a constant-size circuit.

\par We compose these circuits together so that, on input $x$, we compute $C_{T(n)}$ on $M$'s last step in its execution on $x$. We also have a constant size circuit that outputs 1 if and only if $C_{T(n)}$ is an accepting configuration. Since we have $O(T(n))$ circuits of constant size, we have constructed an equivalent $O(T(n))$-size circuit to $M$.

\par For showing strict containment, by \Cref{thm:all_unary_ppoly}, all undecidable unary languages are in $\Ppoly$, which are by definition not in $\P$.
\end{proof}



\newcommand{\CKTSAT}{\lang{CKT-SAT}}
\subsection{\CKTSAT}
As we proved the Cook-Levin Theorem from before, now we prove the circuit analog of $\SAT$. $\CKTSAT$ is the set of all circuits that have a ``satisfying assignment" to the $n$ input variables. In other words, there exists a $w \in \{0, 1\}^n$ if and only if $C(w)=1$ if $C \in \CKTSAT$.

\begin{theorem}
$\CKTSAT$ is $\NP$-complete.
\end{theorem}

\begin{proof}
$\CKTSAT$ is clearly in $\NP$. For hardness, if $L \in \NP$, then there is a verifier $V$ such that, on input $x$, verifies if $x \in L$ in polynomial time. By \Cref{thm:p_subset_ppoly}, we can convert $V$ into an equivalent circuit $C$ in polynomial time. Therefore, $x \in L$ if and only if $C \in \CKTSAT$.
\end{proof}

\subsection{Advice!}
We defined $\Ppoly$ in one way - now we will see another. This will make the fact that all undecidable unary languages are in $\Ppoly$ to be more clear. 

\begin{definition}
The set of languages \emph{decidable by $T(n)$-time TMs with $A(n)$ bits of advice} is called $\DTIME(T(n))/A(n)$. By this, we mean that for every $L \in \DTIME(T(n))/A(n)$, there is a sequence of strings, $\{a_n\}$, each of length $A(n)$, and a $T(n)$-time verifier $M$, such that it accepts $\langle x, a_n \rangle$ if and only if $x \in L$.
\end{definition}

In other words, we are given a sequence of strings of length $A(n)$ that are certificates, in a sense. Now we will look at the alternative definition of $\Ppoly$:
\begin{theorem}
$\Ppoly$ can be re-defined to be $\bigcup_{c, d \ge 0} \DTIME(n^c)/n^d$.
\end{theorem}

\begin{proof}
By the first definition of $\Ppoly$, if $L \in \Ppoly$, then $L$ is computable by a poly-size circuit family $\{C_n\}$. We can just use the descriptions of each of the $C_n$ as an advice string, and the TM is poly-time that, on input $\langle x, C \rangle$, where $C$ is an $n$-input circuit, outputs $C(x)$. 

\par If $L$ is decided by a poly-time TM $M$ with access to the sequence of advice strings $\{a_n\}$, each of poly-length, then we can use the construction of \Cref{thm:p_subset_ppoly} to obtain an equivalent poly-size circuit $B_n$ for all $n$ (i.e., outputs the same as $M$ does). Let $C_n$ be the same as $B_n$ but with $a_n$ hard-coded as the second input (i.e., fix the inputs). Therefore, $\{C_n\}$ is the desired circuit-family.
\end{proof}

We can actually get a ``nondeterministic" parallel to \Cref{thm:p_subset_ppoly}:

\begin{theorem}
$\NP \subseteq \bigcup_{c, d \ge 0} \NTIME(n^c)/n^d$, and the inclusion is strict (note $\NTIME$ instead of $\DTIME$).
\end{theorem}

\begin{proof}
It's easy to see inclusion: set $d = 0$, and have an $\NP$ machine accept a one-bit advice string for every $n$, and have the machine ignore the advice. 

\par For strict inclusion, we know that all unary languages are in $\DTIME(n)/1 \subseteq \NTIME(n)/1$, because we only need one bit of advice for each $n$ in advising the machine to check if $1^n$ is in the language. However, the following undecidable language is also in there, and therefore is not in $\NP$:
\begin{center}
$UHALT = \{1^n \colon n$'s binary expansion encodes $\langle M, w \rangle$ where $M$ halts on $w$\}.
\end{center}
\end{proof}

We have proved both of these, but how does $\NP$ relate to $\Ppoly$ (instead of the $\NTIME$ version)? We actually don't know for sure, as the polynomial hierarchy would collapse:

\begin{theorem}[Karp-Lipton]
If $\NP \subseteq \Ppoly$, then $\PH = \Sigma_2^\P$.
\end{theorem}

\begin{proof}
It is sufficient to show that $\NP \subseteq \Ppoly$ implies $\Sigma_3^\P \subseteq \Sigma_2^\P$. So fix a language $L \in \Sigma_3^\P$. By definition, there exists a poly-time TM $M$ and a polynomial $p$ such that if $x \in L$, then:
\begin{center}
$\exists u_1 \in \{0, 1\}^{p(|x|)} \forall u_2 \in \{0, 1\}^{p(|x|)} \exists u_3 \in \{0, 1\}^{p(|x|)} M(x, u_1, u_2, u_3)$ accepts.
\end{center}
We re-arrange this as follows with a new language $L'$: $\langle x, u_1, u_2 \rangle \in L'$ if and only if:
\begin{center}
$\exists u_3 \in \{0, 1\}^{p(|x|)} M(x, u_1, u_2, u_3)$ accepts.
\end{center}
Therefore, $L' \in \NP$ and therefore $L' \le_P \ThreeSAT$. Therefore, $\langle x, u_1, u_2 \rangle \in L'$ if and only if there exists a $\ThreeSAT$ formula $\phi$ over $x, u_1, u_2$ (reduction done in poly time). Also a NDTM $M'$ decides $L'$.

\par Now just plug in $M'$: $x \in L$ if and only if:
\begin{center}
$\exists u_1 \in \{0, 1\}^{p(|x|)} \forall u_2 \in \{0, 1\}^{p(|x|)} M'(x, u_1, u_2)$ accepts.
\end{center}
This is equivalent to:
\begin{center}
$\exists u_1 \in \{0, 1\}^{p(|x|)} \forall u_2 \in \{0, 1\}^{p(|x|)} \phi(x, u_1, u_2) \in \ThreeSAT$.
\end{center}
Now here is the central part of the proof. We assume that $\NP \subseteq \Ppoly$. Therefore, there exists a poly-size circuit $C$ for $\ThreeSAT$. We can just use $C$ to decide the expression above. So how do we find the circuit in the first place?

\par We prove the following. There exists a poly-time TM $M_C$ that, on input 3CNF formula $\phi$ with $|\phi| = n$ and a circuit $C$ with $n$ inputs such that: 
\begin{enumerate}
\item If $C$ recognizes $\ThreeSAT$ for inputs of length $n$ and $\phi \in \ThreeSAT$, then $M_C$ accepts.
\item If $\phi \notin \ThreeSAT$, then $M_C$ rejects.
\end{enumerate}
The idea is the following: repeatedly use the circuit $C$ to extract a satisfying assignment for $\phi$. Let the variables of $\phi$ be $x_1, ..., x_k$. If $C$ on input $\phi$ outputs 0, then $M_C$ rejects. Otherwise, fix $x_1$ to be false, and check if $C$ outputs 1 on the new circuit. If so, permanently fix $x_1$ to be false, and also have an array of $k$ values, and store $x_1$ to be the first element. Repeat for the other $k-1$ variables. Now we check: if $\phi$ with the assignments given have $\phi$ be true, then accept; otherwise, reject.

\par So now we go back to the original proof: we modify the statement above to be:
\begin{center}
$\exists C$ of poly-size $\exists u_1 \in \{0, 1\}^{p(|x|)} \forall u_2 \in \{0, 1\}^{p(|x|)} \M_C(C, \langle x, u_1, u_2\rangle)$ accepts.
\end{center}
Therefore, $L \in \Sigma_2^\P$.
\end{proof}

\subsection{$\AC, \NC$}
We have dealt with circuits of polynomial size, but what about the other direction? We define a similar analogue of $\L, \NL$ in space complexity but for circuits.

\begin{definition}
For $d \in \mathbb{N}$, we say $L \in \NC^d$ if L is decided by a family of poly-size, $O(\log^d n)$-depth circuits $\{C_n\}$, and $L \in \AC^d$ the same way but the gates have unbounded fan-in. We also define $\NC = \bigcup_{d \ge 0}\NC^d$ and $\AC = \bigcup_{d \ge 0}\AC^d$.
\end{definition}
So how much power does unbounded fan-in give? It only gives enough power to add a log-factor:

\begin{theorem}
$\NC^d \subseteq \AC^d \subseteq \NC^{d+1}$.
\end{theorem}
\begin{proof}
Unbounded fan-in can be simulated by a $O(\log n)$-depth tree of OR/AND gates.
\end{proof}

\subsection*{Exercises}

\begin{enumerate}
\item A language $L \subseteq \{0, 1\}^*$ is sparse if there is a polynomial $p$ such that $|L \cap \{0, 1\}^n| \le p(n)$ for every $n \in \mathbb{N}$. Show that every sparse language is in $\Ppoly$.
\item Going off the previous question, show that if a sparse language is $\NP$-complete, then $\P = \NP$.
\end{enumerate}